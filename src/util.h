#ifndef __GI_UTIL_H__ 
#define __GI_UTIL_H__ 

/*! \file util.h
 * 	\brief general utilities for gi algorithms.
 * 	\note will also be included in cuda source. take care.
 */

#include <librta/cuda-kernels.h>
#include <librta/cuda-vec.h>

namespace gi {

	float halton(int index, int base);

	namespace cuda {
		
		/*! \brief 32 bit linear congruential random number generator, copied from gpu gems 3. */
		heterogenous inline unsigned int lcg_step(unsigned int *z, const unsigned int A, const unsigned int C)  {  
			return *z=(A**z+C);  
		}

		/*! \brief Random data for path tracing.
		 *
		 *  We store 3 floats for light sampling (choose light, choose position
		 *  on light) and 3 floats for path sampling (choose component, choose
		 *  direction).
		 *  N gives the number of explicitely stored path samples.
		 *
		 *  Not used, yet. Should be used for precomputed halton sequences.
		 */
		struct pt_random_data {
			float3 *data;
			int N;
			pt_random_data() : data(0), N(0) {}
		};

		/*! \brief State for linear congruential random number generator.
		 *  
		 *  This is the cheapest random number generator, memory-wise.
		 */
		struct lcg_random_state {
			unsigned int *data;
			int N;
			lcg_random_state() : data(0), N(0) {}
			heterogenous float random_float(int id) {
				return 2.3283064365387e-10 * lcg_step(&data[id], 1664525, 1013904223U);
			}
		};

		/*! \brief Generated N random state cells to be used with the \ref
		 *  uniform_random_lcg generator.
		 *  \note The data is initialized.
		 *  \note The pointer in the returned structure points to gpu memory.
		 */
		lcg_random_state generate_lcg_pool_on_gpu(int N);

		struct halton_pool2f {
			float2 *data;
			int N;
			halton_pool2f() : data(0), N(0) {}
		};

		/*! \brief Generates N float2 values generated by halton (2,3). 
		 *  \note The data is initialized.
		 *  \note The pointer in the returned structure points to gpu memory.
		 */
		halton_pool2f generate_halton_pool_on_gpu(int N);


		heterogenous inline float3 next_random3f(halton_pool2f &pool, int id, int current_sample, int max_samples) {
			float2 f2 = pool.data[(max_samples * id + current_sample) % pool.N];
			return make_float3(f2.x, f2.y, f2.y);
		}

		heterogenous inline float3 next_random3f(lcg_random_state &pool, int id, int, int) {
			float3 f3;
			f3.x = pool.random_float(id);
			f3.y = pool.random_float(id);
			f3.z = pool.random_float(id);
			return f3;
		}

	}
}

#endif


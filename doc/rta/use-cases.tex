\documentclass[a4paper,11pt]{scrartcl}

% packages and settings [[[

% input	[[[
\usepackage[utf8]{inputenc}
% \usepackage{ngerman}
% ]]]
% math/symbols [[[

\usepackage{latexsym}
\usepackage{amsfonts}	
\usepackage{amsmath}
\usepackage{amssymb}

% \usepackage{wasysym}	\Smile
% ]]]
% tables/graphics/algorithms/listings [[[

\usepackage{booktabs}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{varwidth}
% \usepackage{xcolor}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

\usepackage{algorithmicx}
\usepackage{algorithm} % http://ctan.org/pkg/algorithms
\usepackage[noend]{algpseudocode} % http://ctan.org/pkg/algorithmicx
\newcommand*{\Let}[2]{\State #1 $\gets$ \parbox[t]{\linegoal}{#2\strut}}
% \algnewcommand\algorithmicinput{\textbf{INPUT: }}
% \algnewcommand\Input{\item[\algorithmicinput]}
% \algnewcommand\algorithmicoutput{\textbf{OUTPUT: }}
% \algnewcommand\Output{\item[\algorithmicoutput]}

% \usepackage{algorithmic}
% \usepackage[boxed]{algorithm}
\usepackage{subfigure}
\usepackage[margin=10pt,font=small,labelfont=bf]{caption}		
	% \caption zb. in \figure wird \small

% nicer comment formatting in algorithmic env.
% \renewcommand{\algorithmiccomment}[1]{\hspace{\stretch{1}}// #1$\quad$}
% \floatname{algorithm}{Algorithmus}

% drawin trees
% \usepackage{pstricks,pst-node,pst-tree}

% ]]]
% paragraph formatting [[[
\usepackage{a4wide}

\usepackage{parskip}
\parindent0pt
\setlength{\parskip}{1ex plus 0.5ex minus 0.2 ex}

% ]]]

% ]]]
% my commands [[[

% my math commands [[[

\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\mts}{\;|\;}
\newcommand{\eqs}{\;=\;}
\newcommand{\D}{\mathrm{d}}
\newcommand{\Z}{\mathbb{Z}}
\renewcommand{\P}{\mathbb{P}}
\newcommand{\area}{\mathrm{area}}
\newcommand{\matrixtwo}[2]{\left(\begin{array}{cc}#1\\#2\end{array}\right)}
\newcommand{\matrixthree}[3]{\left(\begin{array}{ccc}#1\\#2\\#3\end{array}\right)}
\newcommand{\matrixfour}[4]{\left(\begin{array}{cccc}#1\\#2\\#3\\#4\end{array}\right)}
\newcommand{\vect}[3]{\left(\begin{array}{c}#1\\#2\\#3\end{array}\right)}
\newcommand{\vectfour}[4]{\left(\begin{array}{c}#1\\#2\\#3\\#4\end{array}\right)}
\newcommand{\norm}{\mathrm{norm}}
\newcommand{\scalPr}[2]{\left\langle #1|#2 \right\rangle}

% ]]]
% definitions [[[

\newcounter{currdefinition}
\newcommand{\defnr}[1]{\arabic{#1}}
\newcommand{\defref}[1]{Definition \defnr{#1}}
\newcommand{\definition}[2]
	{	\addtocounter{currdefinition}{1}%
		\newcounter{#1}%
		\setcounter{#1}{\thecurrdefinition}%
		\label{#1}%
		\paragraph{\textbf{Definition \thecurrdefinition:}}\ \\#2}

% ]]]
% misc commands [[[

\newcommand{\ra}{$\rightarrow\ $}
\newcommand{\wichtig}[1]{\framebox{\begin{minipage}[h]{\textwidth}#1\end{minipage}} }
\newcommand{\nachvollz}[1]{\paragraph{\textbf{Nachvollziehen:}}\ \\#1}
\newcommand{\tableitemization}{\hspace{10pt}$\bullet$&}
\newcommand{\HELP}[1]{\ \\\ \\\Huge Hilfe! \normalsize\\$\rightarrow$\ #1\ \\\ \\}

\newcommand{\inlinecode}[1]{{\tt #1}}
\newcommand{\inlineshell}[1]{{\tt #1}}

% ]]]
% levels [[[

\newcommand{\levelA}[1]{\section{#1}}
\newcommand{\levelB}[1]{\subsection{#1}}
\newcommand{\levelC}[1]{\subsubsection{#1}}
\newcommand{\levelD}[1]{\paragraph{#1:}\ \\}
\newcommand{\levelDn}[1]{\paragraph{#1:}}    % level D ohne "\ \\" --> bei paragraph oder itemization direkt danach sonst zu großer zwischenraum
\newcommand{\levelE}[1]{\paragraph{#1:}\ \\}
\newcommand{\levelEn}[1]{\paragraph{#1:}}    % level D ohne "\ \\" --> bei paragraph oder itemization direkt danach sonst zu großer zwischenraum

% ]]]

% ]]]

\usepackage{comment}

\definecolor{numbergray}{gray}{0.5}

% settings for listing environment
\lstset{language=C++,
		basicstyle=\ttfamily\footnotesize,
		frame=lines,
        breaklines=true,
        breakatwhitespace=true,
		keywordstyle=\color{OliveGreen},
		numbers=left,
		numberstyle=\color{numbergray}\scriptsize,
		framexleftmargin=5mm,
		xleftmargin=5mm,
		tabsize=4,
		commentstyle=\color{CadetBlue},
		stringstyle=\color{Bittersweet},
		showstringspaces=false,
		escapechar=@,
		% C++ KEYWORDS
		morekeywords={
			float3,float2,vec3f,vec2f,
			std,string,vector},
		classoffset=1,
		% RTA KEYWORDS
		morekeywords={
			rta,cgls,cuda,simple_triangle,simple_aabb,convert_scene_to_cuda_triangle_data,basic_flat_triangle_list,cpu_ftl,
			connection,rt_set,plugin_create_rt_set,box_t,tri_t,acceleration_structure,
			basic_ctor,basic_rt,basic_as,build,basic_acceleration_structure,as,rt,
			input_flat_triangle_list,expects_host_triangles,cuda_triangle_data,
			declare_traits_types,cam_ray_generator_shirley,gpu_ray_bouncer,tri_ptr,trace_further-bounces,bounce,identification,
			trace_further_bounces,gpu_last_intersection,gpu_origin,gpu_direction,new_pass,valid,
			matching_any_hit_tracer,matching_closest_hit_tracer,trace_rays,trace,trace_progressively,progressive_trace_running,
			closest_hit_tracer,any_hit_tracer,
			raytracer,basic_raytracer,bouncer},
		keywordstyle=\color{Maroon},
		classoffset=0
}


\title{RTA Use Cases}
\subtitle{Examples of how we put RTA to use \\to implement certain rendering techniques}
\author{Kai}
% \date{\today}

% \setlength{\unitlength}{1mm}
\newenvironment{alg}{
	\medskip\hrule
	\begin{algorithmic}}
	{\end{algorithmic}
	\hrule\medskip}

% 	\noindent\fbox{
% 	\begin{varwidth}{\dimexpr\linewidth-2\fboxsep-2\fboxrule\relax}
%	...}

\begin{document}

\maketitle\thispagestyle{empty}
% \tableofcontents

In this document we demonstrate working configurations of algorithms implemented using RTA 
	(together with the real-time framework CGLS which will appear along the way).
There will be many code examples with identifiers originating from RTA highlighted 
	to make explicit whether an identifier is by the current algorithm implemented or by RTA support code.

The example, though working, will only cover the framework aspect of using RTA to implement the desired algorithm.
Complete code can be found in the source of the globillum program.

Note that the first example shows setup code and a few conceptual aspects, too.

\setcounter{tocdepth}{2}
\tableofcontents

\clearpage
\section{Area Light Sampling}
The basic algorithm is as follows:

\begin{alg}
\State trace primary camera ray
\ForAll{requested samples} 
	\State generate uniform sample on area light
	\State trace shadow ray from primary intersection to sample position
	\State integrate lighting
\EndFor
\end{alg}

The following components are involved:
\begin{itemize}
\item A ray tracer to find the closest scene intersection.
\item A ray tracer for the shadow rays (which finds any hit, not the closest one).
\item A ray generator for the primary rays.
\item A ray bouncer to compute samples starting from the primary intersections.
\end{itemize}

Our implementation will, for the moment, be set to use cuda, only.
RTA computes the different steps of a rendering algorithm in lock-step, 
	i.e.\ the steps outlined in the above algorithm are executed for each ray and only then is the next step considered.
Therefore, when generating samples on the light source, all primary intersections have been found.
This is a design decision to facilitate loose coupling of the different steps, 
	as well as to provide a simple mapping to cuda computations using multiple kernel calls.

\subsection{Obtaining a set of RTA Objects}
Getting the initial set of objects is done the easy way (and in the hope that it will be more portable in the long run)
	by using libhyb's plugin loading infrastructure, as follows.
Note that there is also material setup (\lstinline|gpu_materials|, lines~\ref{setup:gpumat1} and~\ref{setup:gpumat2}) mixed in, 
	which is (at the moment) implemented in the globillum program itself.

\begin{lstlisting}
static rta::cgls::connection *rta_connection = 0;
rta::basic_flat_triangle_list<rta::simple_triangle> *ftl = 0;
rta::cgls::connection::cuda_triangle_data *ctd = 0;
rta::cuda::material_t *gpu_materials = 0;@\label{setup:gpumat1}@

void setup_rta(std::string plugin) {
	vector<string> args;@\label{setup:plugin1}@
	plugin = "bbvh-cuda";

	if (plugin == "bbvh-cuda") {	// just in case
		args.push_back("-A");
		args.push_back("-b"); args.push_back("bsah");@\label{setup:bsah}@
		args.push_back("-t"); args.push_back("cis");
		args.push_back("-l"); args.push_back("2f4");
	}@\label{setup:plugin2}@

	typedef rta::cuda::simple_aabb box_t;
	typedef rta::cuda::simple_triangle tri_t;

	rta_connection = new rta::cgls::connection(plugin, args);@\label{setup:conn1}@
	ctd = rta::cgls::connection@\label{setup:conv1}@
	         ::convert_scene_to_cuda_triangle_data(the_scene);
	static rta::basic_flat_triangle_list<tri_t> the_ftl = ctd->cpu_ftl();@\label{setup:cpuftl1}@
	ftl = &the_ftl;
	rta::rt_set *set = 
		 new rta::rt_set(rta::plugin_create_rt_set(*ftl, rays_w, rays_h));@\label{setup:cpuftl2}@
	gpu_materials = rta::cuda::convert_and_upload_materials();@\label{setup:gpumat2}@

	if (!set->basic_ctor<box_t, tri_t>()->expects_host_triangles()) {@\label{setup:buildgpu1}@
		// the c'tor expects the triangle data on the gpu.
		set->as = set->basic_ctor<box_t,tri_t>()
		             ->build((tri_t::input_flat_triangle_list_t*)&ctd->ftl);@\label{setup:ctor}@
		set->basic_rt<box_t,tri_t>()
		    ->acceleration_structure(
				dynamic_cast<rta::basic_acceleration_structure<box_t,tri_t>*>
				(set->as));
	}@\label{setup:buildgpu2}@
}
\end{lstlisting}

Lines~\ref{setup:plugin1} to~\ref{setup:plugin2} specify the plugin to load and some parameters to it.
These can be found by calling RTA with the plugin you want to find information about:
\begin{lstlisting}[language=bash]
$ rta bbvh-cuda -- --help
\end{lstlisting}
The conversion of a \lstinline|cgls| scene to \lstinline|rta| triangle data is executed in line~\ref{setup:conv1}.
Following this conversion a host-side version of the triangle data is generated (line~\ref{setup:cpuftl1}) 
	and fed to the plugin (line~\ref{setup:cpuftl2}).
For cuda-only code this could have been done more economically by simply handing a single-element fake triangle list to the plugin.
The GPU BVH construction branch (lines~\ref{setup:buildgpu1} to~\ref{setup:buildgpu2}) will then build a proper BVH anyway.
In our use case, however, we want to be able to use BVHs other than LBVH, 
	i.e. a BVH build taking surface area heuristic into consideration (see line~\ref{setup:bsah}), 
	therefore we need to have host-side triangle data, too.

The \lstinline|rt_set| computed in line~\ref{setup:cpuftl2} contains the following items, managed by the called plugin to be compatible:
\begin{itemize}
\item the actual ray tracer (usually closest-hit),
\item the requested and build bvh (see comment on fake \lstinline|ftl| above),
\item a bvh contructor (used in line~\ref{setup:ctor} to trigger a gpu build), and
\item a default generator for primary rays.
\end{itemize}
Note that not ray bouncer is set, yet.

\subsection{Evaluate Material at Primary Intersection}
Material evaluation is implemented by a bouncer which does not generate further rays.
This is how a final computation after tracing can be integrated into RTA.
In the following code we derive from \lstinline|gpu_ray_bouncer| (line~\ref{matev:derv}) to get a \lstinline|bouncer| 
	that is properly integrated and supplied with GPU intersection data (see line~\ref{matev:gpudata}).
\begin{lstlisting}
template<typename _box_t, typename _tri_t>
		struct gpu_material_evaluator 
		: public cuda::gpu_ray_bouncer<forward_traits> {@\label{matev:derv}@
	declare_traits_types;
	cuda::material_t *materials;
	cuda::simple_triangle *tri_ptr;
	float3 *material_colors;
	cuda::cam_ray_generator_shirley *crgs;
	gpu_material_evaluator(uint w, uint h, cuda::material_t *materials, 
	                       cuda::simple_triangle *triangles, 
						   cuda::cam_ray_generator_shirley *crgs)
		: cuda::gpu_ray_bouncer<forward_traits>(w, h), 
		  materials(materials), material_colors(0), tri_ptr(triangles),
		  crgs(crgs) {
		checked_cuda(cudaMalloc(&material_colors, sizeof(float3)*w*h));
	}
	~gpu_material_evaluator() {
		checked_cuda(cudaFree(material_colors));
	}
	virtual bool trace_further_bounces() {
		return false;
	}
	virtual void evaluate_material() {
		rta::cuda
		   ::evaluate_material(this->w, this->h, 
						       this->gpu_last_intersection, @\label{matev:gpudata}@
						       tri_ptr, materials, material_colors, 
						       crgs->gpu_origin, crgs->gpu_direction);
	}
	virtual void bounce() {
		evaluate_material();
	}
	virtual std::string identification() {
		return "evaluate first-hit material on gpu.";
	}
};
\end{lstlisting}
The constructor takes the data dimensions which is required to allocate the intersection data and result colors.
Furthermore we have keep references to the materials, triangles and original rays to implement proper material lookup by
\begin{enumerate}
\item loading the triangle referenced by the intersection data,
\item looking up material (color and texture) information from the referenced triangles,
\item interpolating the triangle data to find texture coordinates and using ray differentials (using neighboring rays).
\end{enumerate}

Note how \lstinline|bounce| triggers an externally defined cuda kernel stub and \lstinline|trace_further_bounces| returns false to stop traversal.



\subsection{Using a Ray Bouncer to Implement the Sampling}
Our implementation of the area light sampler is an extension of the material evaluator presented above.
This is not required, but as we want to combine \emph{direct} illumation with already computed \emph{per-pixel} materials this plays out well.

Therefore, our sampling bouncer derives from the material evaluator and thus takes many of the same c'tor arguments.
Additionally we require a number of (rectangular) lights, a pool of uniform random data (to select light samples) and 
	the number of light samples to be computed.
Note that when a new position is chosen and rendering starts afresh the method \lstinline|new_pass| is called to reset the bouncer's data, 
	i.e. to enable it to later recognize that a call to \lstinline|bounce| is not a continuation of the previous computation.
\begin{lstlisting}
template<typename _box_t, typename _tri_t> 
		struct gpu_cgls_arealight_evaluator 
		: public gpu_material_evaluator<forward_traits> {
	declare_traits_types;
	cuda::cgls::rect_light *lights;
	int nr_of_lights;
	gi::cuda::halton_pool2f uniform_random_numbers;
	float3 *potential_sample_contribution,
	       *output_color; 
	int curr_bounce, samples;
	triangle_intersection<cuda::simple_triangle> *primary_intersection;

	gpu_cgls_arealight_evaluator(uint w, uint h,
	                             cuda::material_t *mtls, 
	                             cuda::simple_triangle *triangles, 
								 cuda::cam_ray_generator_shirley *crgs, 
								 cuda::cgls::rect_light *lights, 
								 int nr_of_lights,
								 gi::cuda::halton_pool2f rnd, 
								 int samples)
	: gpu_material_evaluator<forward_traits>(w, h, mtls, triangles, crgs), 
	  lights(lights), nr_of_lights(nr_of_lights), 
	  uniform_random_numbers(rnd), samples(samples) {
	    // allocate potential_sample_contribution
	    // allocate output_color
	    // allocate primary_intersection
		curr_bounce = 0;
	}
	~gpu_cgls_arealight_evaluator() {
		// free allocated stuff
	}
	virtual void new_pass() {
		curr_bounce = 0;
	}
	virtual bool trace_further_bounces() {
		return (curr_bounce < samples+1);
	}
	virtual void setup_new_arealight_sample() {
		rta::cuda::cgls
		   ::generate_rectlight_sample(
		   		this->w, this->h, lights, nr_of_lights, 
				this->crgs->gpu_origin, this->crgs->gpu_direction, 
				this->crgs->gpu_maxt,
				primary_intersection, this->tri_ptr, 
				uniform_random_numbers, 
				potential_sample_contribution, 
				curr_bounce);
	}
	virtual void integrate_light_sample() {
		rta::cuda::cgls
		   ::integrate_light_sample(
		   		this->w, this->h, this->gpu_last_intersection, 
				potential_sample_contribution,
				this->material_colors, output_color, curr_bounce-1);
	}
	virtual void bounce() {
		if (curr_bounce == 0) {
			// this has to be done before switching the intersection data.
			this->evaluate_material();
			triangle_intersection<cuda::simple_triangle> 
				*tmp = primary_intersection;
			primary_intersection = this->gpu_last_intersection;
			this->gpu_last_intersection = tmp;
			setup_new_arealight_sample();
		}
		else if (curr_bounce > 0) {
			integrate_light_sample();
			if (curr_bounce < samples)
				setup_new_arealight_sample();
		}
		++curr_bounce;
	}
};
\end{lstlisting}
When computing a bounce we have to take care to handle the first bounce differently from the others.
This is because the first bounce is after the computation of the primary intersections, and not part of the actual light sampling.
For this bounce we evaluate materials per pixel as described above and save the primary intersection data.
This is required as further bounces will overwrite the intersection data of the bouncer
	(upon which it is determined if the light sample is visible from the shading point).
We implement this efficiently by simply switching pointers.

As long there are samples left to compute we compute a new sample on the area light and store its contribution in 
	\lstinline|potential_sample_contribution|.
This is convenient as at the time we compute the sample all data required to determine its contribution (if the light is visible, hence `potential')
	is already available.
Sampling the light includes generating a new ray, 
	where the ray's \lstinline|max_t| parameter is used to only intersect geometry between the sample and the light.

Upon a completed light sample we integrate the lighting using a moving average to always have displayable data.
Whether the light source is visible can be read from the intersection data: if the intersection \lstinline|is| is empty (\lstinline|!is.valid()|)
	the light is unoccluded.

\subsection{Progressive Update}
RTA's ray tracer interface provides functions for progressive tracing, where the ray tracer does not loop until the current pass is over,
	but maintains information about the current pass's state.
This can be used by calling \lstinline|trace_progressively(true)| to start a new pass.
Note that this directly computes the first bounce, too.
Further bounces can be computed by calling the function with \lstinline|false|.

We use this to compute a single bounce in each frame (after the tracer has been activated), as in the following code.
\begin{lstlisting}
rt_set set;

void start_new_pass() {
	set.rt->trace_progressively(true);
}
	
void update() {
	if (set.rt->progressive_trace_running()) {
		set.rt->trace_progressively(false);
		gpu_cgls_arealight_evaluator<B,T> *bouncer 
			= dynamic_cast<gpu_cgls_arealight_evaluator<B, T>*>
			  (set.bouncer);
		float3 *colors = bouncer->output_color;
		cuda::cgls::copy_cuda_image_to_texture(w, h, colors, 1.0f);
	}
}
\end{lstlisting}
The copying of color values is implemented in the globillum program, as it is not general.

\subsection{Adding a Shadow Tracer for Light Sampling}
As is, the implementation of the area light sampler finds the closest intersection between the sample point and the light sample.
But since we only need to find out whether there is any intersection casting shadow rays should be more efficient.
In RTA pairs of ray tracers which compute the \emph{closest hit} or \emph{any hit} at all, but are equivalent in any other way, are said to be siblings.
Each ray tracer provides a function \lstinline|matching_any_hit_tracer| or \lstinline|matching_closest_hit_tracer| 
	(for closest-hit and any-hit tracers, respectively) to obtain its sibling.
With this the ease of constructing a ray tracer by creating it from its plugin is transferred to generating its silbing tracer, too.

Adding a shadow tracer to the area light sampler could now be done by two ray bouncers, 
	where the first one is essentially the material evaluator presented above (using a closet-hit tracer).
The second one would then just trace multiple samples on the light source for each primary intersection computed before.

However, we chose a different implementation to be able to keep the existing code.
The complication in this process is that the whole tracing algorithm is driven by the ray tracer itself.
The \lstinline|basic_raytracer|, for example, works as follows:
\begin{alg}
\State initialize a new `pass'.
\State generate initial rays via ray generator.
\Repeat
	\State trace current set of rays via \lstinline|this->trace_rays()|.
	\State invoke ray bouncer.
\Until{bouncer's \lstinline|trace_further_bounces| returns false.}
\end{alg}
As can be seen, the code of the initial ray tracer is only left after the whole pass is completed.
Therefore, it is not easily possible to change the tracer mid-stream
	(actually, it is, by deriving from your target tracer).

Using the progressive-tracing interface, i.e. calling \lstinline|trace_progressively()| instead of \lstinline|trace()|
	this becomes quite straightforward, as illustrated in the following piece of code.
\begin{lstlisting}
rt_set set;
raytracer *shadow_tracer;

void start_new_pass() {
	set.rt->trace_progressively(true);@\label{prog:sr:firstcall}@
	shadow_tracer = dynamic_cast<rta::closest_hit_tracer*>(set.rt)
	                ->matching_any_hit_tracer();@\label{prog:sr:genm}@
}
\end{lstlisting}
The initialization of the progressive trace (line~\ref{prog:sr:firstcall}) stays as it was before,
	we only add the new ray tracer after the setup.
This is done deliberately after the first bounce (line~\ref{prog:sr:genm}), as the silbing tracer is generated via copy c'tors, 
	yielding a tracer exactly in the correct state, i.e. after the first bounce.
Note that generating a sibling tracer is a rather light-weight operation as the copy c'tor implements a shallow copy.

The update code then just uses the shadow tracer instead of the original set's tracer:
\begin{lstlisting}
void update() {
	if (shadow_tracer && shadow_tracer->progressive_trace_running()) {
		shadow_tracer->trace_progressively(false);
		gpu_cgls_arealight_evaluator<B,T> *bouncer 
			= dynamic_cast<gpu_cgls_arealight_evaluator<B, T>*>
			  (set.bouncer);
		float3 *colors = bouncer->output_color;
		cuda::cgls::copy_cuda_image_to_texture(w, h, colors, 1.0f);
	}
}
\end{lstlisting}


\section{Path Tracing}
Notes
\begin{itemize}
\item tandem tracer to properly alternate shadow/closest-hit rays.
\item 2nd raygen is required because path sampling needs the old ray for brdf evaluation
	(otherwise it is overwritten by light samples)
\end{itemize}


\end{document}

% vim: set foldmethod=marker foldmarker=[[[,]]]: 


